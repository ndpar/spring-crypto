package com.ndpar.demo.crypto

import org.bouncycastle.asn1.ASN1BitString
import org.bouncycastle.asn1.ASN1InputStream
import org.bouncycastle.asn1.ASN1Sequence
import org.junit.Assert.assertEquals
import org.junit.Assert.assertTrue
import org.junit.Test
import org.junit.runner.RunWith
import org.springframework.beans.factory.annotation.Value
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.test.context.junit4.SpringRunner
import java.io.ByteArrayInputStream
import java.io.FileWriter
import java.io.StringReader
import java.security.PrivateKey
import java.security.PublicKey
import java.security.cert.X509Certificate
import java.util.*
import javax.annotation.Resource

@SpringBootTest
@RunWith(SpringRunner::class)
class CryptoTest {

    @Value("\${com.ndpar.crypto.root.key}")
    private lateinit var keyPem: String

    @Value("\${com.ndpar.crypto.root.cert}")
    private lateinit var certPem: String

    @Resource
    private lateinit var rootKey: PrivateKey

    @Resource
    private lateinit var rootCert: X509Certificate

    @Test
    fun `generate key pairs and chain of signed certs`() {
        val dn = "CN=Intermediate CA"

        val caKeyPair = generateKeyPair()
        val caCert = signKey(caKeyPair.public, rootKey, rootCert, dn)

        caCert.verify(rootCert.publicKey)
        caCert.checkValidity(Date() + 3600.days)

        assertTrue(157 < caCert.serialNumber.bitLength())
        assertEquals("SHA256WITHECDSA", caCert.sigAlgName)
        assertTrue(caCert.issuerX500Principal.name.contains("Root CA"))
        assertEquals(dn, caCert.subjectX500Principal.name)
        assertEquals(KEY_ALGORITHM, caCert.publicKey.algorithm)
        assertEquals(2, caCert.nonCriticalExtensionOIDs.size)
        assertEquals(2, caCert.criticalExtensionOIDs.size)
        assertTrue(caCert.criticalExtensionOIDs.contains("2.5.29.15")) // key usage

        // check PEM serialization
        readAndWritePrivateKeyPem(caKeyPair.private.toPem().toString())
        readAndWriteCertPem(caCert.toPem().toString())

        // print CA PEM files just in case
        caKeyPair.private.toPem(FileWriter("target/ca-key.pem"))
        caCert.toPem(FileWriter("target/ca-cert.pem"))

        val dhKeyPair = generateKeyPair("secp256k1")
        val dhCert = signKey(
            dhKeyPair.public, caKeyPair.private, caCert, "CN=*.ndpar.org",
            extensions = dhExtensions(dhKeyPair.public, caCert)
        )
        // print ECDH PEM files just in case
        dhKeyPair.private.toPem(FileWriter("target/ecdh-key.pem"))
        dhCert.toPem(FileWriter("target/ecdh-cert.pem"))
    }

    fun encodeBase64Url(publicKey: PublicKey): String {
        val encodedBytes: ByteArray = publicKey.encoded
        val asn1Stream = ASN1InputStream(ByteArrayInputStream(encodedBytes))
        val subjectPublicKeyInfo = asn1Stream.readObject() as ASN1Sequence
        val publicKeyBitString = subjectPublicKeyInfo.getObjectAt(1) as ASN1BitString
        val rawBytesWithCompression = publicKeyBitString.bytes
        val bytes = Arrays.copyOfRange(rawBytesWithCompression, 1, rawBytesWithCompression.size)
        return String(Base64.getUrlEncoder().encode(bytes))
    }

    @Test
    fun `read and write cert PEM generated by openssl`() {
        readAndWriteCertPem(certPem)
    }

    private fun readAndWriteCertPem(pem: String) {
        val result = StringReader(pem).readCert().toPem().toString()
        assertEquals(pem, result)
    }

    @Test
    fun `read and write private key PEM generated by openssl`() {
        readAndWritePrivateKeyPem(keyPem)
    }

    private fun readAndWritePrivateKeyPem(pem: String) {
        val result = StringReader(pem).readPrivateKey().toPem().toString()
        assertEquals(pem, result)
    }
}